def run_simulation():

    import pygame
    import sys
    import random
    import time
    import math

    pygame.init()

    # ---------------- WINDOW SETUP ----------------
    WIDTH = 1000
    HEIGHT = 600
    SIM_WIDTH = 700
    PANEL_WIDTH = 300

    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Rocket Guidance Control Simulation")

    clock = pygame.time.Clock()
    font = pygame.font.SysFont("Consolas", 16)
    big_font = pygame.font.SysFont("Consolas", 20, bold=True)

    # ---------------- STARFIELD ----------------
    stars = [[random.randint(0, SIM_WIDTH), random.randint(0, HEIGHT)]
             for _ in range(100)]

    # ---------------- TARGET ----------------
    target_x = SIM_WIDTH // 2
    target_y = HEIGHT // 2

    # ---------------- ROCKET ----------------
    rocket_x = target_x + 150
    rocket_y = target_y + 100
    vel_x = 0
    vel_y = 0
    trail = []

    THRUST = 400
    FRICTION = 0.96
    MAX_SPEED = 800

    # ---------------- PID (LOCKED) ----------------
    kp = 0.18
    kd = 0.28
    ki = 0.0005

    integral_x = 0
    integral_y = 0
    previous_error_x = 0
    previous_error_y = 0

    mode = "AUTO"
    recovery_start = 0
    recovery_time = 0

    # ---------------- DISTURBANCE STATE ----------------
    current_disturbance = "None"
    disturbance_timer = 0

    storm_particles = []
    cme_active = False
    cme_timer = 0
    cme_vx = 0
    cme_vy = 0
    CME_DURATION = 3

    wind_lines = []
    spark_particles = []

    thruster_fail_active = False
    failed_side = None

    vibration_active = False
    vibration_timer = 0


    def spawn_cme():
        for _ in range(5):
            storm_particles.append({
                "x": random.randint(-100, SIM_WIDTH + 100),
                "y": random.randint(0, HEIGHT),
                "vx": cme_vx,
                "vy": cme_vy,
                "life": random.uniform(0.8, 1.5)
            })


    def draw_rocket(x, y):
        pygame.draw.rect(screen, (210, 210, 220),
                         (x-12, y-25, 24, 50), border_radius=6)
        pygame.draw.polygon(screen, (190, 190, 200),
                            [(x-12, y-25), (x+12, y-25), (x, y-45)])
        pygame.draw.circle(screen, (80, 160, 255),
                           (x, y-10), 6)

        flame_height = random.randint(30, 40)
        pygame.draw.polygon(screen, (255, 200, 0),
                            [(x-6, y+25), (x+6, y+25), (x, y+flame_height)])

        if thruster_fail_active:
            if failed_side == "LEFT":
                pygame.draw.rect(screen, (255,50,50),
                                 (x-18, y-15, 6, 30))
            if failed_side == "RIGHT":
                pygame.draw.rect(screen, (255,50,50),
                                 (x+12, y-15, 6, 30))
            if failed_side == "TOP":
                pygame.draw.rect(screen, (255,50,50),
                                 (x-10, y-50, 20, 6))
            if failed_side == "BOTTOM":
                pygame.draw.rect(screen, (255,50,50),
                                 (x-10, y+30, 20, 6))


    # ================= MAIN LOOP =================
    while True:
        dt = clock.tick(60) / 1000

        # -------- EVENT HANDLING --------
        for event in pygame.event.get():

            if event.type == pygame.QUIT:
                return "quit"

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return "menu"

        keys = pygame.key.get_pressed()

        # ================= DISTURBANCES =================
        if keys[pygame.K_1]:
            angle = random.uniform(0, 2*math.pi)
            force = 350
            vel_x += math.cos(angle) * force
            vel_y += math.sin(angle) * force
            current_disturbance = "Crosswind Burst"
            disturbance_timer = 2
            for _ in range(25):
                wind_lines.append([
                    random.randint(0, SIM_WIDTH),
                    random.randint(0, HEIGHT),
                    random.randint(40, 80),
                    angle
                ])

        if keys[pygame.K_2]:
            angle = random.uniform(0, 2*math.pi)
            force = 500
            vel_x += math.cos(angle) * force
            vel_y += math.sin(angle) * force
            current_disturbance = "Thrust Imbalance"
            disturbance_timer = 2
            for _ in range(40):
                spark_particles.append([
                    rocket_x,
                    rocket_y,
                    random.uniform(-5, 5),
                    random.uniform(-5, 5),
                    random.uniform(0.5, 1.2)
                ])

        if keys[pygame.K_3] and not cme_active:
            current_disturbance = "Solar Storm"
            disturbance_timer = CME_DURATION
            cme_active = True
            cme_timer = 0
            cme_vx = random.choice([-1,1]) * 200
            cme_vy = random.choice([-1,1]) * 120

        if keys[pygame.K_4]:
            thruster_fail_active = True
            failed_side = random.choice(["LEFT","RIGHT","TOP","BOTTOM"])
            current_disturbance = f"Thruster Failure ({failed_side})"
            disturbance_timer = 4

        if keys[pygame.K_5]:
            vibration_active = True
            vibration_timer = 3
            current_disturbance = "Structural Vibration"
            disturbance_timer = 3

        if disturbance_timer > 0:
            disturbance_timer -= dt
        else:
            current_disturbance = "None"
            thruster_fail_active = False
            vibration_active = False

        # ================= SOLAR STORM =================

        if cme_active:
            cme_timer += dt
            vel_x += cme_vx * dt
            vel_y += cme_vy * dt
            vel_x += random.uniform(-100,100) * dt
            spawn_cme()
            if cme_timer >= CME_DURATION:
                cme_active = False
                storm_particles.clear()

        if vibration_active:
            vel_x += math.sin(time.time()*40)*50*dt
            vel_y += math.cos(time.time()*40)*50*dt
            vibration_timer -= dt
            if vibration_timer <= 0:
                vibration_active = False

        # ================= CONTROL SYSTEM =================

        error_x = target_x - rocket_x
        error_y = target_y - rocket_y

        if mode == "AUTO":

            integral_x += error_x * dt
            integral_y += error_y * dt

            derivative_x = (error_x - previous_error_x) / dt
            derivative_y = (error_y - previous_error_y) / dt

            vel_x += (kp*error_x + kd*derivative_x + ki*integral_x) * dt
            vel_y += (kp*error_y + kd*derivative_y + ki*integral_y) * dt

            # Stronger Thruster Failure
            if thruster_fail_active:
                reduction = 0.25
                bias_force = 120

                if failed_side == "LEFT":
                    if vel_x < 0:
                        vel_x *= reduction
                    vel_x += bias_force * dt

                elif failed_side == "RIGHT":
                    if vel_x > 0:
                        vel_x *= reduction
                    vel_x -= bias_force * dt

                elif failed_side == "TOP":
                    if vel_y < 0:
                        vel_y *= reduction
                    vel_y += bias_force * dt

                elif failed_side == "BOTTOM":
                    if vel_y > 0:
                        vel_y *= reduction
                    vel_y -= bias_force * dt

            if abs(error_x) > 300 or abs(error_y) > 300:
                mode = "MANUAL"
                recovery_start = time.time()

        else:
            if keys[pygame.K_UP]: vel_y -= THRUST * dt
            if keys[pygame.K_DOWN]: vel_y += THRUST * dt
            if keys[pygame.K_LEFT]: vel_x -= THRUST * dt
            if keys[pygame.K_RIGHT]: vel_x += THRUST * dt

            if abs(error_x) < 40 and abs(error_y) < 40:
                mode = "AUTO"
                recovery_time = time.time() - recovery_start
                integral_x = 0
                integral_y = 0

        previous_error_x = error_x
        previous_error_y = error_y

        # ================= PHYSICS =================

        vel_x = max(-MAX_SPEED, min(MAX_SPEED, vel_x))
        vel_y = max(-MAX_SPEED, min(MAX_SPEED, vel_y))

        rocket_x += vel_x * dt
        rocket_y += vel_y * dt

        vel_x *= FRICTION
        vel_y *= FRICTION

        trail.append((rocket_x, rocket_y))
        if len(trail) > 40:
            trail.pop(0)

        stability = max(0, 100 - (abs(error_x)+abs(error_y))/3)

        # ================= DRAW =================

        screen.fill((5,5,25))

        for x in range(0, SIM_WIDTH, 40):
            pygame.draw.line(screen, (30,30,50),(x,0),(x,HEIGHT))
        for y in range(0, HEIGHT, 40):
            pygame.draw.line(screen, (30,30,50),(0,y),(SIM_WIDTH,y))

        for star in stars:
            star[1] += 40 * dt
            if star[1] > HEIGHT:
                star[1] = 0
                star[0] = random.randint(0, SIM_WIDTH)
            pygame.draw.circle(screen,(200,200,200),star,1)

        pygame.draw.circle(screen,(0,255,0),(target_x,target_y),15,2)

        for wind in wind_lines:
            wind[0] += math.cos(wind[3])*15
            wind[1] += math.sin(wind[3])*15
            pygame.draw.line(screen,(120,180,255),
                             (wind[0],wind[1]),
                             (wind[0]+wind[2]*math.cos(wind[3]),
                              wind[1]+wind[2]*math.sin(wind[3])),2)

        for spark in spark_particles[:]:
            spark[0]+=spark[2]
            spark[1]+=spark[3]
            spark[4]-=dt
            if spark[4]<=0:
                spark_particles.remove(spark)
            else:
                pygame.draw.circle(screen,(255,220,0),
                                   (int(spark[0]),int(spark[1])),3)

        for p in storm_particles[:]:
            p["x"]+=p["vx"]*dt
            p["y"]+=p["vy"]*dt
            p["life"]-=dt
            if p["life"]<=0:
                storm_particles.remove(p)
            else:
                pygame.draw.circle(screen,(255,140,0),
                                   (int(p["x"]),int(p["y"])),3)

        for i,pos in enumerate(trail):
            alpha=i/len(trail)
            pygame.draw.circle(screen,
                               (0,int(200*alpha),255),
                               (int(pos[0]),int(pos[1])),3)

        draw_x=int(rocket_x)
        draw_y=int(rocket_y)
        if vibration_active:
            draw_x+=random.randint(-3,3)
            draw_y+=random.randint(-3,3)

        draw_rocket(draw_x,draw_y)

        # ================= SIDE PANEL =================

        pygame.draw.rect(screen,(25,25,35),
                         (SIM_WIDTH,0,PANEL_WIDTH,HEIGHT))

        y_offset=20
        screen.blit(big_font.render("ROCKET GUIDANCE",True,(0,255,200)),
                    (SIM_WIDTH+20,y_offset))
        y_offset+=40

        lines=[
            "CREW STATUS",
            "Sunita Williams",
            "Manual Override Authority",
            "",
            f"MODE: {mode}",
            "",
            f"ERROR X: {int(error_x)}",
            f"ERROR Y: {int(error_y)}",
            "",
            f"Kp: {kp}",
            f"Ki: {ki}",
            f"Kd: {kd}",
            "",
            "DISTURBANCE:",
            f"{current_disturbance}",
            "",
            f"RECOVERY TIME: {round(recovery_time,2)} s",
            "",
            f"STABILITY: {int(stability)} %"
        ]

        for line in lines:
            screen.blit(font.render(line,True,(200,200,200)),
                        (SIM_WIDTH+20,y_offset))
            y_offset+=22

        pygame.draw.rect(screen,(80,80,80),
                         (SIM_WIDTH+20,HEIGHT-60,250,20))
        pygame.draw.rect(screen,(0,255,100),
                         (SIM_WIDTH+20,HEIGHT-60,
                          2.5*stability,20))

        pygame.display.update()

if __name__ == "__main__":
    run_simulation()